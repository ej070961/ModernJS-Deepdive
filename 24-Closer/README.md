# 클로저(Closure)

> 클로저는 **함수**와 그 함수가 선언된 **렉시컬 환경**의 조합이다.

## 클로저와 렉시컬 환경

1. **중첩 함수(inner)가 외부 함수보다 오래 살아남는다**

   - `outer`를 호출하면 `inner`를 반환한 뒤 `outer`의 실행 컨텍스트는 스택에서 사라진다.
   - 하지만 `outer`의 렉시컬 환경은 `inner`가 참조하고 있기 때문에 가비지 컬렉터가 제거하지 않는다.

2. **예시 코드**

   ```js
   const x = 1;

   function outer() {
     const x = 10;
     const inner = function () {
       console.log(x);
     };
     return inner;
   }

   const innerFunc = outer();
   innerFunc(); // 10
   ```

   - `innerFunc()`는 `outer`가 반환된 이후에도 `outer`의 `x` 값을 기억해서 `10`을 출력한다.

3. **상위 스코프 기억**
   - 자바스크립트의 모든 함수는 자신이 정의될 때의 **상위 스코프**(렉시컬 환경)를 기억한다.
   - 함수가 어디에서 호출되더라도, 이 상위 스코프의 식별자에 접근·수정할 수 있다.

## 클로저의 범위

- **조건**:
  1. 중첩 함수가 상위 스코프의 식별자를 참조하고
  2. 중첩 함수가 외부 함수보다 더 오래 살아남을 때
- 이 두 가지가 모두 충족될 때 “클로저”가 형성된다.

## 🚀 클로저 활용 예시

- **상태 은닉(Encapsulation)**: 외부에서 직접 접근할 수 없는 변수를 안전하게 관리하고, 특정 함수만 상태를 변경하도록 허용한다.

```js
const increase = (function () {
  let count = 0; // 은닉된 상태 변수
  return function () {
    return ++count; // 클로저를 통해 상태에 접근
  };
})();

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

- 위 코드에서 `count` 변수는 외부에서 직접 접근할 수 없고, `increase` 함수만 `count`를 안전하게 변경할 수 있다.

## 📌 핵심 정리

- **클로저** = 함수 + 그 함수가 선언된 렉시컬 환경
- 중첩 함수가 상위 스코프의 식별자를 참조할 때만 클로저가 생성된다.
- 상태 은닉과 캡슐화, 콜백 함수에서의 문맥 유지 등 다양한 패턴에 활용할 수 있다.
